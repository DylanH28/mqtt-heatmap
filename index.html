<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WateringKart – Live Heatmap (JSON, Cubic 8×8 → 64×64)</title>

  <!-- Plotly for the heatmap -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- MQTT.js browser bundle -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/5.14.1/mqtt.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1rem;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .status {
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
    }
    .status span {
      font-weight: bold;
    }
    #heatmap {
      width: 90vw;
      max-width: 900px;
      height: 70vh;
      max-height: 600px;
      margin-top: 1rem;
    }
    .small {
      font-size: 0.8rem;
      opacity: 0.7;
    }
    code {
      background: #222;
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>WateringKart – Real-Time 8×8 → 64×64 Heatmap (JSON, Cubic)</h1>

  <div class="status">
    Broker (browser): <code>wss://test.mosquitto.org:8081/mqtt</code><br />
    Subscribed topic: <code>wateringkart/+/frame</code><br />
    Status: <span id="status">Connecting…</span><br />
    Last topic: <span id="last-topic">–</span><br />
    Last timestamp (µs): <span id="last-ts">–</span><br />
    Last raw payload: <span id="last-payload">–</span>
  </div>

  <div id="heatmap"></div>

  <p class="small">
    Expected JSON payload:<br />
    <code>{"ts_us": 1234567890, "frame": [64 integer values]}</code><br />
    <code>frame</code> is an array of 64 values (8×8, row-major), upscaled to 64×64 via bicubic interpolation.
  </p>

  <script>
    // === Sizes ===
    const BASE_SIZE = 8;     // incoming frame is 8x8
    const DISPLAY_SIZE = 64; // we upscale to 64x64 for plotting

    // === Helper: clamp ===
    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    // === 1D cubic interpolation (Catmull–Rom spline) ===
    function cubicInterpolate(p0, p1, p2, p3, t) {
      // Catmull–Rom:
      // 0.5 * (2p1 + (-p0 + p2)t + (2p0 - 5p1 + 4p2 - p3)t^2 + (-p0 + 3p1 - 3p2 + p3)t^3)
      const t2 = t * t;
      const t3 = t2 * t;

      return 0.5 * (
        2 * p1 +
        (-p0 + p2) * t +
        (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
        (-p0 + 3 * p1 - 3 * p2 + p3) * t3
      );
    }

    // === Get pixel with clamping at borders ===
    function getPixel(grid, x, y) {
      const yy = clamp(y, 0, grid.length - 1);
      const xx = clamp(x, 0, grid[0].length - 1);
      return grid[yy][xx];
    }

    // === Bicubic interpolation on 2D grid ===
    function bicubicSample(grid, x, y) {
      const xInt = Math.floor(x);
      const yInt = Math.floor(y);
      const tx = x - xInt;
      const ty = y - yInt;

      // 4x4 neighborhood
      const col = [];
      for (let m = -1; m <= 2; m++) {
        const rowVals = [];
        const yy = yInt + m;
        for (let n = -1; n <= 2; n++) {
          const xx = xInt + n;
          rowVals.push(getPixel(grid, xx, yy));
        }
        // Interpolate along x for this row
        const c = cubicInterpolate(rowVals[0], rowVals[1], rowVals[2], rowVals[3], tx);
        col.push(c);
      }

      // Interpolate the 4 intermediate values along y
      return cubicInterpolate(col[0], col[1], col[2], col[3], ty);
    }

    // === Upscale BASE_SIZE x BASE_SIZE to DISPLAY_SIZE x DISPLAY_SIZE ===
    function upscaleGridCubic(sourceGrid, srcSize, dstSize) {
      const dst = [];
      const maxSrcIndex = srcSize - 1;
      const maxDstIndex = dstSize - 1;

      for (let j = 0; j < dstSize; j++) {
        const row = [];
        // Map destination index j to source coordinate
        const srcY = (j * maxSrcIndex) / maxDstIndex;
        for (let i = 0; i < dstSize; i++) {
          const srcX = (i * maxSrcIndex) / maxDstIndex;
          const val = bicubicSample(sourceGrid, srcX, srcY);
          row.push(val);
        }
        dst.push(row);
      }

      return dst;
    }

    // === Heatmap setup ===

    // baseGrid holds the original 8x8 data
    const baseGrid = [];
    for (let y = 0; y < BASE_SIZE; y++) {
      const row = [];
      for (let x = 0; x < BASE_SIZE; x++) {
        row.push(0);
      }
      baseGrid.push(row);
    }

    // x/y labels for the 64x64 display
    const xLabels = Array.from({ length: DISPLAY_SIZE }, (_, i) => i);
    const yLabels = Array.from({ length: DISPLAY_SIZE }, (_, i) => i);

    const heatmapDiv = document.getElementById("heatmap");
    const statusSpan = document.getElementById("status");
    const lastTopicSpan = document.getElementById("last-topic");
    const lastTsSpan = document.getElementById("last-ts");
    const lastPayloadSpan = document.getElementById("last-payload");

    // Initial display grid (all zeros, but upscaled)
    const initialDisplayGrid = upscaleGridCubic(baseGrid, BASE_SIZE, DISPLAY_SIZE);

    Plotly.newPlot(
      heatmapDiv,
      [
        {
          z: initialDisplayGrid,
          x: xLabels,
          y: yLabels,
          type: "heatmap",
          colorscale: "Jet",
          reversescale: false
        }
      ],
      {
        title: "WateringKart – Live 8×8 Frame Upscaled to 64×64 (Cubic)",
        xaxis: { title: "X index (0–63)" },
        yaxis: { title: "Y index (0–63)" }
      }
    );

    function updateHeatmapFromValues(values) {
      // values = array of 64 numbers, row-major 8x8
      if (values.length < BASE_SIZE * BASE_SIZE) {
        console.warn("Not enough values in frame:", values.length);
        return;
      }

      let idx = 0;
      for (let y = 0; y < BASE_SIZE; y++) {
        for (let x = 0; x < BASE_SIZE; x++) {
          baseGrid[y][x] = values[idx++];
        }
      }

      // Create a smooth 64x64 grid via bicubic interpolation
      const displayGrid = upscaleGridCubic(baseGrid, BASE_SIZE, DISPLAY_SIZE);

      Plotly.update(heatmapDiv, { z: [displayGrid] });
    }

    // Parse JSON payload from simulator / device:
    // {"ts_us": <int>, "frame": [64 values]}
    function parseFrameText(text) {
      let obj;
      try {
        obj = JSON.parse(text);
      } catch (e) {
        console.warn("Failed to parse JSON payload:", text, e);
        return null;
      }

      if (!obj || !Array.isArray(obj.frame)) {
        console.warn("Payload missing 'frame' array:", obj);
        return null;
      }

      // ts_us is your timestamp; keep as string for display
      const ts = obj.ts_us ?? obj.ts ?? null;
      const values = obj.frame.map((v) => Number(v));

      if (values.length < BASE_SIZE * BASE_SIZE) {
        console.warn("Frame array too short:", values.length);
        return null;
      }
      if (values.some((v) => Number.isNaN(v))) {
        console.warn("Some frame values are not numeric:", obj.frame);
        return null;
      }

      return { timestamp: ts, values };
    }

    // === MQTT setup ===
    const brokerUrl = "wss://test.mosquitto.org:8081/mqtt";
    const topicFilter = "wateringkart/+/frame";

    const clientId = "web-wateringkart-" + Math.random().toString(16).slice(2);

    const options = {
      clientId,
      clean: true,
      reconnectPeriod: 2000, // ms
      connectTimeout: 30_000
      // Anonymous allowed on test.mosquitto.org
    };

    let client;
    try {
      client = mqtt.connect(brokerUrl, options);
    } catch (err) {
      console.error("MQTT connect error:", err);
      statusSpan.textContent = "Error creating MQTT client (see console)";
    }

    if (client) {
      client.on("connect", () => {
        console.log("Connected to MQTT broker as", clientId);
        statusSpan.textContent = "Connected";
        client.subscribe(topicFilter, (err) => {
          if (err) {
            console.error("Subscription error:", err);
            statusSpan.textContent = "Connected, subscribe failed";
          } else {
            console.log("Subscribed to", topicFilter);
          }
        });
      });

      client.on("reconnect", () => {
        statusSpan.textContent = "Reconnecting…";
      });

      client.on("close", () => {
        statusSpan.textContent = "Disconnected";
      });

      client.on("error", (err) => {
        console.error("MQTT error:", err);
        statusSpan.textContent = "Error (see console)";
      });

      client.on("message", (topicName, payload) => {
        const text = payload.toString();
        lastTopicSpan.textContent = topicName;
        lastPayloadSpan.textContent =
          text.length > 120 ? text.slice(0, 120) + "…" : text;

        const parsed = parseFrameText(text);
        if (!parsed) return;

        lastTsSpan.textContent = parsed.timestamp ?? "–";
        updateHeatmapFromValues(parsed.values);
      });
    }
  </script>
</body>
</html>
